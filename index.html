<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>English Quest ï½œå¤šå¥—å–®å­—é›†ï¼‹è¤‡ç¿’å¡ï¼‹äº”é€£å‹é—–é—œ</title>
  <style>
    :root{
      --pad:14px; --r:18px; --shadow:0 10px 30px rgba(0,0,0,.08);
      --bg:#fafafa; --card:#fff; --muted:#666; --line:#eee;
    }
    body{ margin:0; font-family:system-ui,-apple-system,"Noto Sans TC",sans-serif; background:var(--bg); color:#111; }
    .wrap{ max-width:1050px; margin:0 auto; padding:16px; }
    .top{
      display:flex; gap:12px; flex-wrap:wrap; align-items:center; justify-content:space-between;
      background:var(--card); padding:var(--pad); border-radius:var(--r); box-shadow:var(--shadow);
    }
    h1{ margin:0; font-size:18px; }
    .sub{ font-size:12px; color:#555; margin-top:4px; line-height:1.4; }
    .stats{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .pill{ background:#f1f3f5; padding:8px 10px; border-radius:999px; font-size:13px; }
    .pill b{ font-variant-numeric:tabular-nums; }
    button{
      appearance:none; border:0; cursor:pointer;
      padding:12px 14px; border-radius:14px;
      background:#111; color:#fff; font-size:14px;
    }
    button.secondary{ background:#e9ecef; color:#111; }
    button.good{ background:#0b7285; }
    button.warn{ background:#b42318; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .grid{ display:grid; grid-template-columns: 1.35fr .65fr; gap:14px; margin-top:14px; }
    @media (max-width:980px){ .grid{ grid-template-columns:1fr; } }
    .card{ background:var(--card); padding:var(--pad); border-radius:var(--r); box-shadow:var(--shadow); }
    .card h2{ margin:0 0 10px; font-size:16px; }
    .bar{ height:10px; background:#f1f3f5; border-radius:999px; overflow:hidden; }
    .bar > div{ height:100%; width:0%; background:#111; transition:width .25s ease; }
    .msg{
      margin-top:10px; padding:10px 12px; border-radius:14px; background:#f8f9fa;
      border:1px solid #eee; font-size:14px;
    }
    .msg.good{ background:#e6fcf5; border-color:#c3fae8; }
    .msg.warn{ background:#fff5f5; border-color:#ffe3e3; }
    .mini{ font-size:12px; color:#666; line-height:1.4; }

    /* top set switch */
    select{
      padding:10px 12px; border-radius:14px; border:1px solid #e9ecef;
      background:#fff; font-size:14px;
    }
    input, textarea{
      width:100%; padding:12px; border-radius:14px;
      border:1px solid #e9ecef; font-size:14px; outline:none;
    }
    .divider{ height:1px; background:var(--line); margin:12px 0; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }

    /* Tabs */
    .tabs{ display:flex; gap:10px; flex-wrap:wrap; }
    .tabBtn{ background:#e9ecef; color:#111; }
    .tabBtn.active{ background:#111; color:#fff; }

    /* Flashcard */
    .flashWrap{ display:flex; flex-direction:column; gap:10px; }
    .flashCard{
      user-select:none;
      display:flex; align-items:center; justify-content:center;
      height:220px; border-radius:22px;
      background:#f6f7f9; border:2px solid transparent;
      font-size:40px; letter-spacing:.5px;
      position:relative;
      text-align:center;
      padding:14px;
    }
    .cornerTag{
      position:absolute; top:10px; left:10px;
      font-size:12px; color:#444; background:#fff;
      padding:6px 10px; border-radius:999px; border:1px solid var(--line);
    }
    .cornerStreak{
      position:absolute; top:10px; right:10px;
      font-size:12px; color:#444; background:#fff;
      padding:6px 10px; border-radius:999px; border:1px solid var(--line);
    }

    /* Quiz */
    .promptBig{ font-size:34px; margin:6px 0 8px; }
    .choices{ display:grid; grid-template-columns:1fr 1fr; gap:10px; margin-top:12px; }
    @media (max-width:520px){ .choices{ grid-template-columns:1fr; } }
    .choice{
      text-align:left; background:#f6f7f9; color:#111;
      border:2px solid transparent;
      padding:14px; border-radius:16px;
    }
    .choice strong{ display:block; font-size:16px; margin-bottom:4px; }
    .choice small{ color:#666; }
    .choice.correct{ border-color:#2f9e44; background:#ebfbee; }
    .choice.wrong{ border-color:#e03131; background:#fff5f5; }

    /* Spelling */
    .spellBox{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-top:10px;
    }
    .wordSlots{
      display:flex; gap:6px; flex-wrap:wrap;
      padding:10px 12px; background:#f8f9fa; border:1px solid var(--line);
      border-radius:14px; min-height:44px; align-items:center;
      font-size:18px;
    }
    .slot{
      width:18px; height:26px;
      border-bottom:2px solid #bbb;
      display:inline-flex; align-items:flex-end; justify-content:center;
    }
    .letters{
      display:flex; flex-wrap:wrap; gap:8px; margin-top:12px;
    }
    .letterBtn{
      background:#e9ecef; color:#111; border-radius:14px; padding:10px 12px; border:0; cursor:pointer;
      font-size:16px;
    }

    /* Teacher list */
    .list{ display:flex; flex-direction:column; gap:8px; max-height:260px; overflow:auto; }
    .wordItem{ display:flex; justify-content:space-between; gap:10px; align-items:center; padding:10px 12px; background:#f8f9fa; border-radius:14px; }
    .wordItem .w{ display:flex; flex-direction:column; }
    .wordItem .w b{ font-size:14px; }
    .wordItem .w span{ font-size:12px; color:#666; }
    .danger{ background:#ffe3e3; color:#c92a2a; }

    .badge{
      background:#f1f3f5; padding:6px 10px; border-radius:999px; font-size:12px;
      border:1px solid #e9ecef;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div style="min-width:280px">
        <h1>ğŸ® English Quest ï½œå¤šå¥—å–®å­—é›†ï¼ˆç¯‡ç« ï¼‰ï¼‹è¤‡ç¿’å¡ â†’ äº”é€£å‹é—–é—œ</h1>
        <div class="sub">
          å…ˆå–®å­—å¡ç¿»é¢ï¼‹è½éŸ³è¤‡ç¿’ï¼Œå†é€²éŠç©æª¢é©—ï¼šæ¯å€‹å–®å­—è¦ã€Œé€£çºŒç­”å° 5 æ¬¡ã€æ‰ç®—å®Œæˆï¼›ç­”éŒ¯è©²å­—æ­¸é›¶ä½†èˆ‡å…¶ä»–å­—äº¤å‰å‡ºç¾ã€‚
        </div>
      </div>

      <div class="stats">
        <div class="row">
          <span class="badge">ç›®å‰å–®å­—é›†ï¼š</span>
          <select id="setSelect"></select>
          <button class="secondary" id="btnRenameSet">âœï¸ æ”¹å</button>
        </div>
        <div class="pill">éšæ®µ <b id="phaseLabel">è¤‡ç¿’</b></div>
        <div class="pill">å®Œæˆ <b id="masteredCount">0</b>/<b id="totalCount">0</b></div>
        <button class="secondary" id="toggleTeacher">è€å¸«æ¨¡å¼</button>
      </div>
    </div>

    <div class="grid">
      <!-- Main -->
      <div class="card">
        <div class="tabs">
          <button class="tabBtn active" id="tabReview">ğŸƒ å–®å­—è¤‡ç¿’</button>
          <button class="tabBtn" id="tabPlay">ğŸ•¹ï¸ éŠç©æª¢é©—</button>
        </div>

        <div class="divider"></div>

        <!-- REVIEW -->
        <div id="reviewView">
          <h2>å–®å­—è¤‡ç¿’ï¼ˆé»å¡ç‰‡ç¿»é¢ï½œğŸ”Š å¯é‡æ’­ï¼‰</h2>
          <div class="flashWrap">
            <div class="flashCard" id="flashCard" title="é»æˆ‘ç¿»é¢">
              <div class="cornerTag" id="flashSide">EN</div>
              <div class="cornerStreak" id="flashProgress">0/5</div>
              <div id="flashText">jump</div>
            </div>
            <div class="row">
              <button class="secondary" id="btnSpeakCard">ğŸ”Š æ’­æ”¾</button>
              <button class="secondary" id="btnPrevCard">â¬… ä¸Šä¸€å¼µ</button>
              <button class="secondary" id="btnNextCard">ä¸‹ä¸€å¼µ â¡</button>
              <button class="good" id="btnStartPlay">é–‹å§‹æª¢é©— ğŸ•¹ï¸</button>
            </div>
            <div class="mini">
              å°æŠ€å·§ï¼šã€Œè½ â†’ è·Ÿå”¸ â†’ ç¿»ä¸­æ–‡ç¢ºèªã€å†ä¸‹ä¸€å¼µã€‚åŠ æ²¹å¯¶ï¼ä½ åšå¾—åˆ°ï¼
            </div>
          </div>
        </div>

        <!-- PLAY -->
        <div id="playView" style="display:none">
          <div class="row" style="justify-content:space-between">
            <h2 style="margin:0">éŠç©æª¢é©—ï¼ˆäº¤å‰å‡ºé¡Œï½œæ¯å­—äº”é€£å‹ï¼‰</h2>
            <div class="row">
              <label class="mini">æ¨¡å¼ï¼š</label>
              <select id="modeSelect">
                <option value="listen_zh_mc">â‘  è½åŠ›ï¼šè½è‹±é¸ä¸­æ–‡</option>
                <option value="listen_en_mc">â‘¡ è½åŠ›ï¼šè½è‹±é¸è‹±æ–‡</option>
                <option value="zh_to_en">â‘¢ çœ‹ä¸­æ–‡é¸è‹±æ–‡</option>
                <option value="en_to_zh">â‘£ çœ‹è‹±æ–‡é¸ä¸­æ–‡</option>
                <option value="listen_spell">â‘¤ è½åŠ›ï¼šè½è‹±æ‹¼å–®å­—</option>
                <option value="mixed" selected>â‘¥ æ··åˆå‡ºé¡Œï¼ˆæ¨è–¦ï¼‰</option>
              </select>
              <button class="secondary" id="btnReplay">ğŸ”Š é‡æ’­</button>
              <button class="secondary" id="btnBackToReview">å›è¤‡ç¿’ ğŸƒ</button>
            </div>
          </div>

          <div class="bar" style="margin-top:10px"><div id="progressBar"></div></div>

          <!-- Multiple choice prompt -->
          <div id="mcBlock">
            <div class="promptBig" id="promptText">ï¼ˆé¡Œç›®ï¼‰</div>
            <div class="mini" id="promptHint">æç¤ºï¼šæŒ‰ã€Œé‡æ’­ã€å¯å†è½ä¸€æ¬¡ã€‚</div>
            <div class="choices" id="choices"></div>
          </div>

          <!-- Spelling prompt -->
          <div id="spellBlock" style="display:none">
            <div class="promptBig" id="spellTitle">è½éŸ³æ‹¼å–®å­—</div>
            <div class="mini">æŒ‰ã€Œé‡æ’­ã€è½éŸ³ â†’ é»ä¸‹é¢å­—æ¯æ‹¼å‡ºå–®å­—ï¼ˆä¸ç”¨éµç›¤ï¼‰</div>

            <div class="spellBox">
              <div class="wordSlots" id="slots"></div>
              <button class="secondary" id="btnBackspace">âŒ« åˆªé™¤</button>
              <button class="good" id="btnSubmitSpell">é€å‡º</button>
              <button class="secondary" id="btnClearSpell">æ¸…ç©º</button>
            </div>
            <div class="letters" id="letters"></div>
          </div>

          <div class="msg" id="message" style="display:none"></div>
          <div class="mini" style="margin-top:10px">
            âœ… çµæŸæ¢ä»¶ï¼šæ¯å€‹å–®å­—ã€Œé€£å‹ 5 æ¬¡ã€å®Œæˆã€‚<br>
            âŒ è‹¥è©²å­—ç­”éŒ¯ï¼šè©²å­—é€£å‹æ­¸é›¶ï¼Œä½†æœƒèˆ‡å…¶ä»–å–®å­—äº¤å‰å‡ºç¾ç›´åˆ°å†æ¬¡é€£å‹ 5 æ¬¡ã€‚
          </div>
        </div>
      </div>

      <!-- Teacher -->
      <div class="card" id="teacherCard" style="display:none">
        <h2>ğŸ§‘â€ğŸ« è€å¸«æ¨¡å¼ï¼ˆç¯‡ç« ç®¡ç†ï¼‹æ‰¹æ¬¡è¼¸å…¥ï¼šé€è¡Œé…å°ï¼‰</h2>
        <div class="mini">
          ä½ å¯ä»¥æ–°å¢ã€Œé¡è‰²ç¯‡ / å‹•ä½œç¯‡ / ç‰©å“ç¯‡â€¦ã€ï¼Œæ¯ç¯‡éƒ½æœ‰è‡ªå·±çš„å–®å­—åº«èˆ‡é—–é—œé€²åº¦ï¼Œé—œæ‰ä¹Ÿæœƒä¿ç•™ã€‚
        </div>

        <div class="divider"></div>

        <div class="row">
          <button id="btnNewSet">â• æ–°å¢ä¸€ç¯‡</button>
          <button class="secondary" id="btnDuplicateSet">ğŸ“„ è¤‡è£½ç›®å‰é€™ç¯‡</button>
          <button class="secondary danger" id="btnDeleteSet">ğŸ—‘ï¸ åˆªé™¤ç›®å‰é€™ç¯‡</button>
          <button class="secondary" id="btnResetProgress">ğŸ”„ é‡ç½®æœ¬ç¯‡é€²åº¦</button>
        </div>

        <div class="divider"></div>

        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
          <div>
            <div class="mini">è‹±æ–‡ï¼ˆæ¯è¡Œä¸€å€‹ï¼‰</div>
            <textarea id="bulkEn" rows="10" placeholder="jump&#10;run&#10;book"></textarea>
          </div>
          <div>
            <div class="mini">ä¸­æ–‡ï¼ˆæ¯è¡Œä¸€å€‹ï¼‰</div>
            <textarea id="bulkZh" rows="10" placeholder="è·³&#10;è·‘&#10;æ›¸"></textarea>
          </div>
        </div>

        <div class="row" style="margin-top:10px">
          <button id="applyBulk">âœ… å¥—ç”¨åˆ°æœ¬ç¯‡å–®å­—åº«</button>
          <button class="secondary" id="resetDefault">â†© æ¢å¾©é è¨­ï¼ˆè¦†è“‹æœ¬ç¯‡ï¼‰</button>
          <button class="secondary" id="exportAll">â¬‡ åŒ¯å‡ºå…¨éƒ¨ç¯‡ç« </button>
          <button class="secondary" id="importAll">â¬† åŒ¯å…¥å…¨éƒ¨ç¯‡ç« </button>
        </div>

        <div class="divider"></div>
        <div class="mini">æœ¬ç¯‡ç›®å‰å–®å­—ï¼ˆåˆªé™¤åªå½±éŸ¿æœ¬ç¯‡ï¼‰</div>
        <div class="list" id="wordList"></div>

        <textarea id="ioBox" rows="7" style="margin-top:10px" placeholder="åŒ¯å…¥/åŒ¯å‡ºç”¨ï¼šé€™è£¡æœƒå‡ºç¾ JSONï¼ˆåŒ…å«å…¨éƒ¨ç¯‡ç« ï¼‰"></textarea>
        <div class="mini">åŒ¯å‡ºå¯è¤‡è£½åˆ°å¦ä¸€å°å¹³æ¿åŒ¯å…¥ï¼ˆé›¢ç·šä¹Ÿå¯ä»¥ï¼‰ã€‚</div>
      </div>
    </div>
  </div>

<script>
(() => {
  // =================== Storage schema ===================
  // EQV4_DATA = { activeSetId, sets: { setId: { name, words:[{en,zh}] } } }
  // EQV4_PROGRESS = { setId: { en: streak0to5 } }
  // EQV4_STATE = { phase, reviewIndex, mode }
  const KEY_DATA = "eqv4.data";
  const KEY_PROGRESS = "eqv4.progress";
  const KEY_STATE = "eqv4.state";

  const DEFAULT_WORDS = [
    { en:"jump", zh:"è·³" }, { en:"run", zh:"è·‘" }, { en:"sit", zh:"åä¸‹" }, { en:"stand", zh:"ç«™èµ·ä¾†" },
    { en:"book", zh:"æ›¸" }, { en:"pen", zh:"ç­†" }, { en:"door", zh:"é–€" }, { en:"chair", zh:"æ¤…å­" },
    { en:"red", zh:"ç´…è‰²" }, { en:"blue", zh:"è—è‰²" }, { en:"big", zh:"å¤§" }, { en:"small", zh:"å°" },
    { en:"open", zh:"æ‰“é–‹" }, { en:"close", zh:"é—œä¸Š" }, { en:"touch", zh:"ç¢°ä¸€ä¸‹" }, { en:"look", zh:"çœ‹" },
  ];

  function uid(){
    return "s_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function sanitizeWords(arr){
    const cleaned = [];
    const seen = new Set();
    for(const x of arr || []){
      if(!x || !x.en || !x.zh) continue;
      const en = String(x.en).trim().toLowerCase();
      const zh = String(x.zh).trim();
      if(!en || !zh) continue;
      if(seen.has(en)) continue;
      seen.add(en);
      cleaned.push({ en, zh });
    }
    return cleaned;
  }

  function loadData(){
    try{
      const raw = localStorage.getItem(KEY_DATA);
      if(!raw){
        const id = uid();
        const data = {
          activeSetId: id,
          sets: {
            [id]: { name: "é è¨­ç¯‡", words: [...DEFAULT_WORDS] }
          }
        };
        localStorage.setItem(KEY_DATA, JSON.stringify(data));
        return data;
      }
      const data = JSON.parse(raw);
      if(!data?.sets || !data.activeSetId || !data.sets[data.activeSetId]){
        // repair
        const id = uid();
        const fixed = { activeSetId: id, sets: { [id]: { name:"é è¨­ç¯‡", words:[...DEFAULT_WORDS] } } };
        localStorage.setItem(KEY_DATA, JSON.stringify(fixed));
        return fixed;
      }
      // sanitize each set's words
      for(const sid of Object.keys(data.sets)){
        const s = data.sets[sid];
        if(!s?.name) s.name = "æœªå‘½åç¯‡";
        s.words = sanitizeWords(s.words);
      }
      localStorage.setItem(KEY_DATA, JSON.stringify(data));
      return data;
    } catch {
      const id = uid();
      const data = { activeSetId: id, sets: { [id]: { name:"é è¨­ç¯‡", words:[...DEFAULT_WORDS] } } };
      localStorage.setItem(KEY_DATA, JSON.stringify(data));
      return data;
    }
  }

  function saveData(data){
    localStorage.setItem(KEY_DATA, JSON.stringify(data));
  }

  function loadProgress(){
    try{
      const raw = localStorage.getItem(KEY_PROGRESS);
      if(!raw) return {};
      const p = JSON.parse(raw);
      return (p && typeof p === "object") ? p : {};
    } catch { return {}; }
  }
  function saveProgress(p){
    localStorage.setItem(KEY_PROGRESS, JSON.stringify(p));
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(KEY_STATE);
      if(!raw) return { phase:"review", reviewIndex:0, mode:"mixed" };
      const s = JSON.parse(raw);
      return { phase:"review", reviewIndex:0, mode:"mixed", ...s };
    } catch { return { phase:"review", reviewIndex:0, mode:"mixed" }; }
  }
  function saveState(s){ localStorage.setItem(KEY_STATE, JSON.stringify(s)); }

  // =================== TTS ===================
  function speakEN(text){
    try{
      if(!("speechSynthesis" in window)) return;
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "en-US";
      u.rate = 0.9;
      u.pitch = 1.0;
      u.volume = 1.0;
      window.speechSynthesis.speak(u);
    } catch {}
  }

  // =================== Helpers ===================
  const $ = (id) => document.getElementById(id);
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, (c)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]));
  }
  function shuffle(arr){
    const a = [...arr];
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }
  function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
  function pickOthers(all, correct, n){
    const pool = all.filter(x => x !== correct);
    const picked = [];
    while(picked.length < n && pool.length){
      const idx = Math.floor(Math.random()*pool.length);
      picked.push(pool[idx]);
      pool.splice(idx,1);
    }
    while(picked.length < n) picked.push("ï¼ˆç©ºï¼‰");
    return picked;
  }

  // =================== UI refs ===================
  const setSelect = $("setSelect");
  const btnRenameSet = $("btnRenameSet");

  const phaseLabel = $("phaseLabel");
  const masteredCount = $("masteredCount");
  const totalCount = $("totalCount");

  const tabReview = $("tabReview");
  const tabPlay = $("tabPlay");
  const reviewView = $("reviewView");
  const playView = $("playView");

  const flashCard = $("flashCard");
  const flashText = $("flashText");
  const flashSide = $("flashSide");
  const flashProgress = $("flashProgress");
  const btnSpeakCard = $("btnSpeakCard");
  const btnPrevCard = $("btnPrevCard");
  const btnNextCard = $("btnNextCard");
  const btnStartPlay = $("btnStartPlay");

  const modeSelect = $("modeSelect");
  const btnReplay = $("btnReplay");
  const btnBackToReview = $("btnBackToReview");
  const progressBar = $("progressBar");
  const message = $("message");

  const mcBlock = $("mcBlock");
  const promptText = $("promptText");
  const promptHint = $("promptHint");
  const choicesEl = $("choices");

  const spellBlock = $("spellBlock");
  const slotsEl = $("slots");
  const lettersEl = $("letters");
  const btnBackspace = $("btnBackspace");
  const btnSubmitSpell = $("btnSubmitSpell");
  const btnClearSpell = $("btnClearSpell");

  // teacher
  const teacherCard = $("teacherCard");
  const toggleTeacher = $("toggleTeacher");
  const btnNewSet = $("btnNewSet");
  const btnDuplicateSet = $("btnDuplicateSet");
  const btnDeleteSet = $("btnDeleteSet");
  const btnResetProgress = $("btnResetProgress");
  const bulkEn = $("bulkEn");
  const bulkZh = $("bulkZh");
  const applyBulk = $("applyBulk");
  const resetDefault = $("resetDefault");
  const exportAll = $("exportAll");
  const importAll = $("importAll");
  const ioBox = $("ioBox");
  const wordList = $("wordList");

  // =================== Runtime state ===================
  let data = loadData();
  let progressAll = loadProgress();
  let state = loadState();

  function getActiveSet(){
    return data.sets[data.activeSetId];
  }
  function getActiveWords(){
    return getActiveSet().words || [];
  }

  function ensureProgressForActiveSet(){
    const sid = data.activeSetId;
    progressAll[sid] = progressAll[sid] || {};
    const map = progressAll[sid];

    // add missing words
    for(const w of getActiveWords()){
      if(typeof map[w.en] !== "number") map[w.en] = 0;
    }
    // remove deleted words
    for(const en of Object.keys(map)){
      if(!getActiveWords().find(w => w.en === en)) delete map[en];
    }
    saveProgress(progressAll);
  }

  function setActiveSetId(sid){
    if(!data.sets[sid]) return;
    data.activeSetId = sid;
    saveData(data);
    ensureProgressForActiveSet();
    // reset review index to safe range
    state.reviewIndex = 0;
    saveState(state);
    // refresh UI views
    fillSetSelect();
    renderWordList();
    renderTeacherBulk();
    setPhase(state.phase || "review");
  }

  function fillSetSelect(){
    setSelect.innerHTML = "";
    const entries = Object.entries(data.sets);
    // stable ordering: active first then name
    entries.sort((a,b) => {
      const [ida,sa] = a; const [idb,sb] = b;
      if(ida === data.activeSetId) return -1;
      if(idb === data.activeSetId) return 1;
      return String(sa.name).localeCompare(String(sb.name));
    });

    for(const [sid, s] of entries){
      const opt = document.createElement("option");
      opt.value = sid;
      opt.textContent = s.name || "æœªå‘½åç¯‡";
      setSelect.appendChild(opt);
    }
    setSelect.value = data.activeSetId;
  }

  // =================== Messaging ===================
  function showMsg(text, kind){
    message.style.display = "block";
    message.textContent = text;
    message.className = "msg" + (kind ? (" " + kind) : "");
  }
  function hideMsg(){
    message.style.display = "none";
    message.textContent = "";
    message.className = "msg";
  }

  // =================== Mastery UI ===================
  function getStreak(en){
    const sid = data.activeSetId;
    return progressAll?.[sid]?.[en] ?? 0;
  }
  function setStreak(en, val){
    const sid = data.activeSetId;
    progressAll[sid] = progressAll[sid] || {};
    progressAll[sid][en] = clamp(val, 0, 5);
    saveProgress(progressAll);
  }
  function updateMasteryUI(){
    const words = getActiveWords();
    const sid = data.activeSetId;
    const map = progressAll[sid] || {};
    const mastered = words.filter(w => (map[w.en] ?? 0) >= 5).length;
    masteredCount.textContent = mastered;
    totalCount.textContent = words.length;
    const pct = words.length ? Math.round((mastered/words.length)*100) : 0;
    progressBar.style.width = pct + "%";
  }

  // =================== Tabs / Phase ===================
  let reviewSide = "EN";
  function setPhase(phase){
    state.phase = phase;
    saveState(state);

    if(phase === "review"){
      phaseLabel.textContent = "è¤‡ç¿’";
      tabReview.classList.add("active");
      tabPlay.classList.remove("active");
      reviewView.style.display = "";
      playView.style.display = "none";
      renderReview();
    } else {
      phaseLabel.textContent = "æª¢é©—";
      tabPlay.classList.add("active");
      tabReview.classList.remove("active");
      reviewView.style.display = "none";
      playView.style.display = "";
      renderQuestion(true);
    }
  }

  tabReview.addEventListener("click", () => setPhase("review"));
  tabPlay.addEventListener("click", () => setPhase("play"));
  btnBackToReview.addEventListener("click", () => setPhase("review"));

  // =================== Review (Flashcards) ===================
  function renderReview(){
    ensureProgressForActiveSet();
    const words = getActiveWords();
    if(!words.length){
      flashText.textContent = "ï¼ˆæœ¬ç¯‡æ²’æœ‰å–®å­—ï¼‰";
      flashSide.textContent = "EN";
      flashProgress.textContent = "0/5";
      return;
    }
    let idx = clamp(state.reviewIndex ?? 0, 0, words.length-1);
    state.reviewIndex = idx;
    saveState(state);

    const w = words[idx];
    const streak = getStreak(w.en);

    flashProgress.textContent = `${clamp(streak,0,5)}/5`;
    flashSide.textContent = reviewSide;
    flashText.textContent = (reviewSide === "EN") ? w.en : w.zh;

    if(reviewSide === "EN") speakEN(w.en);
    updateMasteryUI();
  }

  function flipCard(){
    reviewSide = (reviewSide === "EN") ? "ZH" : "EN";
    renderReview();
  }
  flashCard.addEventListener("click", flipCard);

  btnSpeakCard.addEventListener("click", () => {
    const words = getActiveWords();
    if(!words.length) return;
    const w = words[clamp(state.reviewIndex ?? 0, 0, words.length-1)];
    speakEN(w.en);
  });

  btnPrevCard.addEventListener("click", () => {
    const words = getActiveWords();
    if(!words.length) return;
    reviewSide = "EN";
    state.reviewIndex = clamp((state.reviewIndex ?? 0) - 1, 0, words.length-1);
    saveState(state);
    renderReview();
  });

  btnNextCard.addEventListener("click", () => {
    const words = getActiveWords();
    if(!words.length) return;
    reviewSide = "EN";
    state.reviewIndex = clamp((state.reviewIndex ?? 0) + 1, 0, words.length-1);
    saveState(state);
    renderReview();
  });

  btnStartPlay.addEventListener("click", () => {
    reviewSide = "EN";
    setPhase("play");
  });

  // =================== Play logic: interleaving picker ===================
  let currentWord = null;
  let lastEn = null;

  function unfinishedWords(){
    const words = getActiveWords();
    return words.filter(w => getStreak(w.en) < 5);
  }

  function pickNextWord(){
    const pool = unfinishedWords();
    if(!pool.length) return null;

    const candidates = pool.filter(w => w.en !== lastEn);
    const usePool = candidates.length ? candidates : pool;

    // weight: (5 - streak)^2 + 1  => streakå°æ›´å¸¸å‡º
    const weights = usePool.map(w => {
      const s = getStreak(w.en);
      const base = (5 - s);
      return (base*base) + 1;
    });

    const sum = weights.reduce((a,b)=>a+b,0);
    let r = Math.random() * sum;
    for(let i=0;i<usePool.length;i++){
      r -= weights[i];
      if(r <= 0) return usePool[i];
    }
    return usePool[usePool.length-1];
  }

  // =================== Modes ===================
  const MODES = ["listen_zh_mc","listen_en_mc","zh_to_en","en_to_zh","listen_spell"];

  function getActiveMode(){
    const val = modeSelect.value;
    if(val === "mixed"){
      return MODES[Math.floor(Math.random()*MODES.length)];
    }
    return val;
  }

  modeSelect.value = state.mode || "mixed";
  modeSelect.addEventListener("change", () => {
    state.mode = modeSelect.value;
    saveState(state);
    renderQuestion(true);
  });

  btnReplay.addEventListener("click", () => {
    if(!currentWord) return;
    speakEN(currentWord.en);
  });

  // =================== Render MC ===================
  function renderMCQuestion(mode, w){
    mcBlock.style.display = "";
    spellBlock.style.display = "none";
    hideMsg();

    const words = getActiveWords();

    if(mode === "listen_zh_mc"){
      promptText.textContent = "ğŸ§ è½åŠ›é¡Œï¼šè½è‹±é¸ä¸­æ–‡";
      promptHint.textContent = "æŒ‰ã€Œé‡æ’­ã€å†è½ä¸€æ¬¡ã€‚";
      speakEN(w.en);

      const correct = w.zh;
      const others = pickOthers(words.map(x=>x.zh), correct, 3);
      const opts = shuffle([correct, ...others]).map(x => ({ label:x, value:x, correct: x===correct }));
      renderChoices(opts, picked => picked === correct);
      return;
    }

    if(mode === "listen_en_mc"){
      promptText.textContent = "ğŸ§ è½åŠ›é¡Œï¼šè½è‹±é¸è‹±æ–‡";
      promptHint.textContent = "æŒ‰ã€Œé‡æ’­ã€å†è½ä¸€æ¬¡ã€‚";
      speakEN(w.en);

      const correct = w.en;
      const others = pickOthers(words.map(x=>x.en), correct, 3);
      const opts = shuffle([correct, ...others]).map(x => ({ label:x, value:x, correct: x===correct }));
      renderChoices(opts, picked => picked === correct);
      return;
    }

    if(mode === "zh_to_en"){
      promptText.textContent = w.zh;
      promptHint.textContent = "çœ‹ä¸­æ–‡é¸è‹±æ–‡ï¼ˆå¯æŒ‰é‡æ’­è½ç™¼éŸ³ï¼‰ã€‚";
      const correct = w.en;
      const others = pickOthers(words.map(x=>x.en), correct, 3);
      const opts = shuffle([correct, ...others]).map(x => ({ label:x, value:x, correct: x===correct }));
      renderChoices(opts, picked => picked === correct);
      return;
    }

    if(mode === "en_to_zh"){
      promptText.textContent = w.en;
      promptHint.textContent = "çœ‹è‹±æ–‡é¸ä¸­æ–‡ï¼ˆå¯æŒ‰é‡æ’­è½ç™¼éŸ³ï¼‰ã€‚";
      speakEN(w.en);
      const correct = w.zh;
      const others = pickOthers(words.map(x=>x.zh), correct, 3);
      const opts = shuffle([correct, ...others]).map(x => ({ label:x, value:x, correct: x===correct }));
      renderChoices(opts, picked => picked === correct);
      return;
    }
  }

  function renderChoices(opts, checker){
    choicesEl.innerHTML = "";
    opts.forEach((c, idx) => {
      const btn = document.createElement("button");
      btn.className = "choice";
      btn.innerHTML = `<strong>${escapeHtml(c.label)}</strong><small>é»ä¸€ä¸‹é¸æ“‡</small>`;
      btn.addEventListener("click", () => {
        const isCorrect = checker(c.value);
        const correctIdx = opts.findIndex(x => x.correct);

        [...choicesEl.children].forEach((el, i) => {
          el.classList.remove("correct","wrong");
          if(i === correctIdx) el.classList.add("correct");
          if(i === idx && idx !== correctIdx) el.classList.add("wrong");
        });

        handleAnswer(isCorrect);
      });
      choicesEl.appendChild(btn);
    });
  }

  // =================== Spelling ===================
  let spellTarget = "";
  let spellBuilt = "";
  let spellLetters = [];

  function renderSpellingQuestion(w){
    mcBlock.style.display = "none";
    spellBlock.style.display = "";
    hideMsg();

    speakEN(w.en);
    spellTarget = w.en.toLowerCase();
    spellBuilt = "";

    const letters = spellTarget.split("");
    const distractPool = "abcdefghijklmnopqrstuvwxyz".split("").filter(ch => !letters.includes(ch));
    const distract = shuffle(distractPool).slice(0, Math.min(3, distractPool.length));
    spellLetters = shuffle([...letters, ...distract]);

    renderSlots();
    renderLetterButtons();
  }

  function renderSlots(){
    slotsEl.innerHTML = "";
    for(let i=0;i<spellTarget.length;i++){
      const d = document.createElement("div");
      d.className = "slot";
      d.textContent = spellBuilt[i] ? spellBuilt[i] : "";
      slotsEl.appendChild(d);
    }
  }

  function renderLetterButtons(){
    lettersEl.innerHTML = "";
    spellLetters.forEach((ch) => {
      const b = document.createElement("button");
      b.className = "letterBtn";
      b.textContent = ch;
      b.addEventListener("click", () => {
        if(spellBuilt.length >= spellTarget.length) return;
        spellBuilt += ch;
        renderSlots();
      });
      lettersEl.appendChild(b);
    });
  }

  btnBackspace.addEventListener("click", () => {
    spellBuilt = spellBuilt.slice(0, -1);
    renderSlots();
  });
  btnClearSpell.addEventListener("click", () => {
    spellBuilt = "";
    renderSlots();
  });
  btnSubmitSpell.addEventListener("click", () => {
    const isCorrect = (spellBuilt.toLowerCase() === spellTarget);
    if(isCorrect){
      showMsg("âœ… æ‹¼å°äº†ï¼", "good");
    } else {
      showMsg(`ğŸ§© å¡é—œäº†ï¼šæ­£ç¢ºæ˜¯ã€Œ${spellTarget}ã€ï¼ˆå…ˆè¨˜ä½å†ä¸‹ä¸€é¡Œï¼‰`, "warn");
    }
    handleAnswer(isCorrect, true);
  });

  // =================== Answer handling: per-word consecutive correct ===================
  function handleAnswer(isCorrect, delay=false){
    if(!currentWord) return;
    const en = currentWord.en;
    const s = getStreak(en);

    if(isCorrect){
      setStreak(en, s + 1);
      const ns = getStreak(en);
      showMsg(`âœ… éé—œï¼ã€Œ${en}ã€é€£å‹ï¼š${ns}/5`, "good");
    } else {
      setStreak(en, 0);
      showMsg(`ğŸ›¡ï¸ å¡é—œï¼šæ²’é—œä¿‚ï¼ã€Œ${en}ã€é€£å‹æ­¸é›¶ï¼Œä¹‹å¾Œæœƒäº¤å‰å†å‡ºç¾ç›´åˆ°é€£å‹ 5 æ¬¡`, "warn");
    }

    updateMasteryUI();

    const done = unfinishedWords().length === 0;
    if(done){
      setTimeout(() => {
        mcBlock.style.display = "";
        spellBlock.style.display = "none";
        choicesEl.innerHTML = "";
        promptText.textContent = "ğŸ‰ æœ¬ç¯‡å®Œæˆï¼æ¯å€‹å–®å­—éƒ½é€£å‹ 5 æ¬¡äº†";
        promptHint.textContent = "ä½ å¯ä»¥æ›ç¯‡ç« ã€å›è¤‡ç¿’ï¼Œæˆ–è€å¸«æ¨¡å¼æ–°å¢æ–°ç¯‡ç« ã€‚";
        showMsg("è¶…å¼·ï¼ä»Šå¤©ä»»å‹™å®Œæˆ âœ…", "good");
      }, delay ? 650 : 500);
      return;
    }

    setTimeout(() => renderQuestion(false), delay ? 900 : 650);
  }

  // =================== Render question ===================
  function renderQuestion(resetLast){
    ensureProgressForActiveSet();
    const words = getActiveWords();
    if(!words.length){
      promptText.textContent = "ï¼ˆæœ¬ç¯‡æ²’æœ‰å–®å­—ï¼Œè«‹åˆ°è€å¸«æ¨¡å¼æ–°å¢ï¼‰";
      choicesEl.innerHTML = "";
      return;
    }
    if(resetLast) lastEn = null;

    currentWord = pickNextWord();
    if(!currentWord){
      updateMasteryUI();
      promptText.textContent = "ğŸ‰ æœ¬ç¯‡å®Œæˆï¼";
      return;
    }
    lastEn = currentWord.en;

    const mode = getActiveMode();
    if(mode === "listen_spell"){
      renderSpellingQuestion(currentWord);
      return;
    }
    renderMCQuestion(mode, currentWord);
  }

  // =================== Teacher: set management ===================
  function renderTeacherBulk(){
    const set = getActiveSet();
    const words = set.words || [];
    bulkEn.value = words.map(w => w.en).join("\n");
    bulkZh.value = words.map(w => w.zh).join("\n");
  }

  function renderWordList(){
    wordList.innerHTML = "";
    const words = getActiveWords();
    words.forEach((w, idx) => {
      const div = document.createElement("div");
      div.className = "wordItem";
      div.innerHTML = `
        <div class="w">
          <b>${escapeHtml(w.en)}</b>
          <span>${escapeHtml(w.zh)}</span>
        </div>
        <button class="secondary danger">åˆªé™¤</button>
      `;
      div.querySelector("button").addEventListener("click", () => {
        const set = getActiveSet();
        set.words.splice(idx, 1);
        set.words = sanitizeWords(set.words);
        saveData(data);

        // progress cleanup
        ensureProgressForActiveSet();

        renderWordList();
        renderTeacherBulk();
        updateMasteryUI();
        renderReview();
      });
      wordList.appendChild(div);
    });
  }

  toggleTeacher.addEventListener("click", () => {
    const open = teacherCard.style.display !== "none";
    teacherCard.style.display = open ? "none" : "block";
    toggleTeacher.textContent = open ? "è€å¸«æ¨¡å¼" : "é—œé–‰è€å¸«æ¨¡å¼";
    renderTeacherBulk();
    renderWordList();
  });

  btnNewSet.addEventListener("click", () => {
    const name = prompt("è«‹è¼¸å…¥æ–°ç¯‡ç« åç¨±ï¼ˆä¾‹å¦‚ï¼šé¡è‰²ç¯‡ï¼‰", "æ–°ç¯‡ç« ");
    if(!name) return;

    const id = uid();
    data.sets[id] = { name: name.trim(), words: [] };
    saveData(data);

    progressAll[id] = {};
    saveProgress(progressAll);

    setActiveSetId(id);
    if(teacherCard.style.display !== "none"){
      renderTeacherBulk();
      renderWordList();
    }
  });

  btnDuplicateSet.addEventListener("click", () => {
    const cur = getActiveSet();
    const name = prompt("è¤‡è£½å¾Œçš„ç¯‡ç« åç¨±ï¼š", (cur.name || "æœªå‘½åç¯‡") + "ï¼ˆè¤‡è£½ï¼‰");
    if(!name) return;

    const id = uid();
    data.sets[id] = { name: name.trim(), words: sanitizeWords(cur.words) };
    saveData(data);

    // copy progress as 0 (æ›´ç›´è¦ºï¼šæ–°ç¯‡ç« é‡æ–°æŒ‘æˆ°)
    progressAll[id] = {};
    saveProgress(progressAll);

    setActiveSetId(id);
  });

  btnDeleteSet.addEventListener("click", () => {
    const keys = Object.keys(data.sets);
    if(keys.length <= 1){
      alert("è‡³å°‘è¦ä¿ç•™ä¸€ç¯‡ï¼Œä¸èƒ½åˆªé™¤æœ€å¾Œä¸€ç¯‡ã€‚");
      return;
    }
    const cur = getActiveSet();
    const ok = confirm(`ç¢ºå®šè¦åˆªé™¤ã€Œ${cur.name}ã€é€™ä¸€ç¯‡å—ï¼Ÿï¼ˆå–®å­—èˆ‡é€²åº¦éƒ½æœƒç§»é™¤ï¼‰`);
    if(!ok) return;

    const sid = data.activeSetId;
    delete data.sets[sid];
    delete progressAll[sid];
    saveData(data);
    saveProgress(progressAll);

    // switch to first remaining set
    const nextId = Object.keys(data.sets)[0];
    data.activeSetId = nextId;
    saveData(data);
    setActiveSetId(nextId);
  });

  btnResetProgress.addEventListener("click", () => {
    const cur = getActiveSet();
    const ok = confirm(`è¦é‡ç½®ã€Œ${cur.name}ã€çš„é—–é—œé€²åº¦å—ï¼Ÿï¼ˆæ‰€æœ‰å–®å­—é€£å‹æ­¸é›¶ï¼‰`);
    if(!ok) return;

    progressAll[data.activeSetId] = {};
    saveProgress(progressAll);
    ensureProgressForActiveSet();

    renderReview();
    updateMasteryUI();
    if(state.phase === "play") renderQuestion(true);
    alert("å·²é‡ç½®æœ¬ç¯‡é€²åº¦ã€‚");
  });

  btnRenameSet.addEventListener("click", () => {
    const cur = getActiveSet();
    const name = prompt("è«‹è¼¸å…¥æ–°çš„ç¯‡ç« åç¨±ï¼š", cur.name || "æœªå‘½åç¯‡");
    if(!name) return;
    cur.name = name.trim();
    saveData(data);
    fillSetSelect();
  });

  applyBulk.addEventListener("click", () => {
    const ens = bulkEn.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const zhs = bulkZh.value.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const n = Math.min(ens.length, zhs.length);

    const arr = [];
    for(let i=0;i<n;i++){
      arr.push({ en: ens[i].toLowerCase(), zh: zhs[i] });
    }

    const cleaned = sanitizeWords(arr);
    getActiveSet().words = cleaned;
    saveData(data);

    // reset progress for this set to avoid mismatch
    progressAll[data.activeSetId] = {};
    saveProgress(progressAll);
    ensureProgressForActiveSet();

    state.reviewIndex = 0;
    saveState(state);
    reviewSide = "EN";

    renderTeacherBulk();
    renderWordList();
    renderReview();
    updateMasteryUI();
    alert("å·²å¥—ç”¨æœ¬ç¯‡å–®å­—åº«ï¼Œä¸¦é‡ç½®æœ¬ç¯‡é—–é—œé€²åº¦ã€‚");
  });

  resetDefault.addEventListener("click", () => {
    const ok = confirm("è¦ç”¨ã€Œé è¨­å–®å­—ã€è¦†è“‹æœ¬ç¯‡å—ï¼Ÿï¼ˆæœ¬ç¯‡åŸæœ¬å–®å­—æœƒè¢«å–ä»£ï¼Œé€²åº¦é‡ç½®ï¼‰");
    if(!ok) return;

    getActiveSet().words = sanitizeWords(DEFAULT_WORDS);
    saveData(data);

    progressAll[data.activeSetId] = {};
    saveProgress(progressAll);
    ensureProgressForActiveSet();

    state.reviewIndex = 0;
    saveState(state);
    reviewSide = "EN";

    renderTeacherBulk();
    renderWordList();
    renderReview();
    updateMasteryUI();
  });

  exportAll.addEventListener("click", () => {
    const payload = {
      data: loadData(),
      progress: loadProgress()
    };
    ioBox.value = JSON.stringify(payload, null, 2);
    ioBox.focus();
    ioBox.select();
    alert("å·²åŒ¯å‡ºï¼ˆåŒ…å«å…¨éƒ¨ç¯‡ç« ï¼‹é€²åº¦ï¼‰åˆ°æ–‡å­—æ¡†ï¼Œå¯è¤‡è£½åˆ°åˆ¥å°åŒ¯å…¥ã€‚");
  });

  importAll.addEventListener("click", () => {
    try{
      const payload = JSON.parse(ioBox.value);
      if(!payload?.data?.sets || !payload?.data?.activeSetId) throw new Error("bad");
      // sanitize sets
      const sets = payload.data.sets;
      for(const sid of Object.keys(sets)){
        sets[sid].name = String(sets[sid].name || "æœªå‘½åç¯‡");
        sets[sid].words = sanitizeWords(sets[sid].words);
      }
      // ensure active exists
      if(!sets[payload.data.activeSetId]){
        payload.data.activeSetId = Object.keys(sets)[0];
      }

      localStorage.setItem(KEY_DATA, JSON.stringify(payload.data));
      localStorage.setItem(KEY_PROGRESS, JSON.stringify(payload.progress || {}));

      data = loadData();
      progressAll = loadProgress();
      ensureProgressForActiveSet();

      fillSetSelect();
      renderTeacherBulk();
      renderWordList();
      setPhase(state.phase || "review");
      alert("åŒ¯å…¥æˆåŠŸï¼å·²è¼‰å…¥å…¨éƒ¨ç¯‡ç« èˆ‡é€²åº¦ã€‚");
    } catch {
      alert("åŒ¯å…¥å¤±æ•—ï¼šè«‹ç¢ºèªè²¼ä¸Šçš„æ˜¯ã€ŒåŒ¯å‡ºå…¨éƒ¨ç¯‡ç« ã€ç”¢ç”Ÿçš„ JSONã€‚");
    }
  });

  // =================== Set selector ===================
  setSelect.addEventListener("change", () => {
    const sid = setSelect.value;
    setActiveSetId(sid);
  });

  // =================== Init ===================
  fillSetSelect();
  ensureProgressForActiveSet();
  updateMasteryUI();

  // restore phase
  if(state.phase === "play"){
    setPhase("play");
  } else {
    setPhase("review");
  }

  // keep mode
  modeSelect.value = state.mode || "mixed";

  // Ensure teacher UI reflects
  renderTeacherBulk();
  renderWordList();
})();
</script>
</body>
</html>
